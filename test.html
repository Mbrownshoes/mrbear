 
<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.5/leaflet.css" />

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="http://d3js.org/colorbrewer.v1.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.2/leaflet.js"></script>
<script src="pluggins/leaflet-plugins-1.2.1/layer/tile/Bing.js"></script>
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
<style>
 html,
    body {
        height: 100%;
        width: 100%;
    }
    body {
        margin: 0;
    }
    #map {
        width: 100%;
        height: 100%;
    }
    svg {
        position: relative;
    }
    path {
        fill: yellow;
        stroke-width: 2px;
        stroke: red;
        stroke-opacity: 1;
    }
    .travelMarker {
        fill: yellow;
        opacity: 0.75;
    }
    .waypoints {
        fill: black;
        opacity: 0;
    }
}
.drinks {
    stroke: black;
    fill: red;
}
.lineConnect {
    fill: none;
    stroke: #e5f5e0;
    stroke-opacity: .2;
  stroke-linejoin: round;
  stroke-linecap: round;
}
.locnames {
    fill: black;
    text-shadow: 1px 1px 1px #FFF, 3px 3px 5px #000;
    font-weight: bold;
    font-size: 13px;
}
</style>
<body>
<div id="map"></div>
<script>
var tweenToggle = 0;


var basemap = new L.tileLayer('http://otile1.mqcdn.com/tiles/1.0.0/map/{z}/{x}/{y}.png',{
  attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="http://cartodb.com/attributions">CartoDB</a>'
});
//create map object
var map = L.map('map')
    .addLayer(basemap)
    .setView([53, -123.1], 14);
// var geojsonLayer = new L.GeoJSON();
var bing = new L.BingLayer("AhjCmC4ThYrtk-3i-01G6buMsQBPOi0SfZO6CCOyhbd1XTHSkI1T_00AZiCBL1HV");
map.addLayer(bing);


var svg = d3.select(map.getPanes().overlayPane).append("svg");
var g = svg.append("g").attr("class", "leaflet-zoom-hide");

var parseDate = d3.time.format("%y-%m-%d %H:%M:%S").parse;

// putting d3 code here to access ajax response

d3.json("G008.json", function(error, collection) {
    if (error) return console.error(error);
    bear = topojson.feature(collection, collection.objects.subunits);
    // geojsonLayer.addData(data);
 
    var featuresData = bear.features.filter(
        function(d) {
        
            return parseDate(d.properties.timestamp) > parseDate("05-12-31 00:00:00") && parseDate(d.properties.timestamp) < parseDate("07-01-01 00:00:00")
            // console.log(d.properties.catalognumber =="KNTM-2546")
        })


    var transform = d3.geo.transform({
        point: projectPoint
    });
    var d3path = d3.geo.path().projection(transform);
    var toLine = d3.svg.line()
        .interpolate("linear")
        .x(function(d) {
            return applyLatLngToLayer(d).x
        })
        .y(function(d){
            return applyLatLngToLayer(d).y
        });
    var ptFeatures = g.selectAll("circle")
        .data(featuresData)
        .enter()
        .append("circle")
        .attr("r", 3)
        .attr("class", "waypoints");
    var linePath = g.selectAll(".lineConnect")
        .data([featuresData])
        .enter()
        .append("path")
        .attr("class", "lineConnect");
    var marker = g.append("circle")
        .attr("r", 7)
        .attr("id","marker")
        .attr("class", "travelMarker");


    

    var timedate = d3.time.scale()
                        .range([1,120000])
                        .domain([
                            d3.min(featuresData, function(d) {return parseDate(d.properties.timestamp); }),
                            d3.max(featuresData, function(d) {return parseDate(d.properties.timestamp); })
                        ]);

    //need to reset when zooming
    map.on("viewreset",reset);
    reset();
    transition();

    function reset() {
        console.log(d3path.bounds(bear))
        var bounds = d3path.bounds(bear),
            topLeft = bounds[0],
            bottomRight = bounds[1];
        ptFeatures.attr("transform",
                function(d) {
                    return "translate(" +
                        applyLatLngToLayer(d).x + "," +
                        applyLatLngToLayer(d).y + ")";
                });
        marker.attr("transform",
            function() {
                var y = featuresData[0].geometry.coordinates[1]
                console.log(y)
                var x = featuresData[0].geometry.coordinates[0]
                return "translate(" +
                    map.latLngToLayerPoint(new L.LatLng(y, x)).x + "," +
                    map.latLngToLayerPoint(new L.LatLng(y, x)).y + ")";
            });
        // Setting the size and location of the overall SVG container
            svg.attr("width", bottomRight[0] - topLeft[0] + 120)
                .attr("height", bottomRight[1] - topLeft[1] + 120)
                .style("left", topLeft[0] - 50 + "px")
                .style("top", topLeft[1] - 50 + "px");
            // linePath.attr("d", d3path);
            linePath.attr("d", toLine)
            // ptPath.attr("d", d3path);
            g.attr("transform", "translate(" + (-topLeft[0] + 50) + "," + (-topLeft[1] + 50) + ")");
    }// end reset
    function transition() {
        console.log('hi')
        linePath.transition()
            .duration(1000000)
            .delay(function(d, i) {
                console.log(i)
                return timedate(parseDate(d[i].properties.timestamp));
            })
            .ease("linear")
            .attrTween("stroke-dasharray", tweenDash);
            // .each("end", function() {
            //  d3.select(this).call(transition);
            // });
    }
    //this function feeds the attrTween operator above with the stroke and dash lengths
    function tweenDash() {
        return function(t) {
            // console.log(t)
            var l = linePath.node().getTotalLength();
            interpolate = d3.interpolateString("0," + l, l + "," + l);
            var marker = d3.select("#marker");
            var p = linePath.node().getPointAtLength(t * l);
            // move the marker to that point
            marker.attr("transform", "translate(" + p.x + "," + p.y + ")");
        // console.log(tweenToggle)
            if (tweenToggle == 0 | tweenToggle == 5) {
                    tweenToggle = 1;
                    var newCenter = map.layerPointToLatLng(new L.Point(p.x,p.y));
                    //map.setView(newCenter, 14);
                    map.panTo(newCenter, 14);
                } else {
                    tweenToggle++;
                }
            

            return interpolate(t);
        }
    }
    function projectPoint(x, y) {
            var point = map.latLngToLayerPoint(new L.LatLng(y, x));
            this.stream.point(point.x, point.y);
        } //end projectPoint
});
    // similar to projectPoint this function converts lat/long to
    // svg coordinates except that it accepts a point from our 
    // GeoJSON
function applyLatLngToLayer(d) {
    var y = d.geometry.coordinates[1]
    var x = d.geometry.coordinates[0]
    return map.latLngToLayerPoint(new L.LatLng(y,x))
}


// map.addLayer(geojsonLayer);
</script>












